[{"id":0,"href":"/Leetcode/Q26/","title":"Q26","parent":"Leetcode","content":" Remove Duplicates from Sorted Array Type: Data Structure Difficulty: EASY Status: COMPLETE Attempts: 3 Solution: NO Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Tags: Python Array Two Pointers Problem Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n\\( 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 \\) \\( -100 \u0026lt;= nums[i] \u0026lt;= 100 \\) nums is sorted in non-decreasing order. Solution This problem is easy as the array is sorted which eliminates some additional steps needed to sort the array. Sorted array means that the next element in the array can be evaluated based on 1 iteration of the array reducing the time complexity needed when working with unsorted array.\nSpace complexity is required to be O(1) which means that list should not be referenced to a variable. The first step for solving this problem is to initialize a variable that act as a pointer and counter, using the first provided example, this variable is presented as below.\n// initialize variables nums = [1, 1, 2] pointer = 0 To evaluate if the current element is unique, we can reference the first element of the array from the pointer and iterate the array from the second element.\n// array index values nums[0] --\u0026gt; 1 nums[1] --\u0026gt; 1 nums[2] --\u0026gt; 2 // length of array LENGTH of nums is 3 // pseudo code pointer_element = nums[0] --\u0026gt; 1 FOR each element in nums starting from second element WHERE current element is nums[1] --\u0026gt; 1 ENDFOR In this case, the first and second elements have the same value, thus, our pointer will need to be referenced to the second element to replace the second element by the third element. This can be completed with If-Else conditional statement.\npointer_element = nums[0] --\u0026gt; 1 FOR each element in nums WHERE current element is nums[1] --\u0026gt; 1 IF first_element == current_element THEN Do nothing WHICH nums[0] is equal to nums[1] ENDIF ENDFOR The next process continue with identifying if pointer element is the same as the current element in the iteration process. In this second iteration, the pointer element and current element do not match, therfore, the pointer element is being replaced by the current element.\n// second iteration process nums = [1,1,2] pointer = 0 pointer_element = nums[0] --\u0026gt; 1 FOR each element in nums WHERE current element is nums[2] --\u0026gt; 2 IF first_element == current_element THEN Do nothing ELSE pointer is incremented by 1 nums[pointer] is replaced by current element WHICH nums[0] is not equal to nums[2] THEREFORE pointer is 1 and nums[1] = nums[2] ENDIF ENDFOR The result is that nums = [1,2,2] has the second element replaced and the pointer is now on the second element which indicates that the first k should be 2. For the code process, this can be completed by adding 1 to pointer and return the result. For more information about this logic process, please review Attempt 1.\nAttempt 1 This attempt is basically reviewing the logic that was mentioned in the Solution section. The idea is to use a pointer as a reference to replace the next array element with a unique element.\n## use pointer class Solution: def removeDuplicates(self, nums: list[int]) -\u0026gt; int: pointer = 0 ## set pointer ## loop from second element and ends at last second element for idx in range(1, len(nums)): ## do nothing when current element is not unique if nums[idx] == nums[pointer]: pass ## replace the next k element by unique element else: pointer += 1 ## pointer move up for next index nums[pointer] = nums[idx] ## replace for first k print(nums) ## for personal evaluation only return pointer+1 ## make pointer a counter ## personal evaluation s = Solution() print(f\u0026#34;s.removeDuplicates([1,1,2]): k={s.removeDuplicates([1,1,2])}\u0026#34;) print(f\u0026#34;s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k={s.removeDuplicates([0,0,1,1,1,2,2,3,3,4])}\u0026#34;) ## output [1, 2, 2] s.removeDuplicates([1,1,2]): k=2 [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k=5 Runtime: 125 ms Memory: 15.5 mb Attempt 2 This attempt is basically the same as the first attempt but cleaner.\n## use pointer class Solution: def removeDuplicates(self, nums: list[int]) -\u0026gt; int: pointer = 0 ## set pointer ## loop from second element and ends at last second element for idx in range(1, len(nums)): ## replace the next k element by unique element if nums[idx] != nums[pointer]: pointer += 1 ## pointer move up for next index nums[pointer] = nums[idx] ## replace for first k print(nums) ## for personal evaluation only return pointer+1 ## make pointer a counter ## personal evaluation s = Solution() print(f\u0026#34;s.removeDuplicates([1,1,2]): k={s.removeDuplicates([1,1,2])}\u0026#34;) print(f\u0026#34;s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k={s.removeDuplicates([0,0,1,1,1,2,2,3,3,4])}\u0026#34;) ## output [1, 2, 2] s.removeDuplicates([1,1,2]): k=2 [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k=5 Runtime: 144 ms Memory: 15.5 mb Attempt 3 This solution looks at Python built-in data structure set() which takes only unique values and return as a map data structure. The data structure is converted back to a list for submission. Python unique data structure might make this approach the best solution.\nLeetcode is not able to evaluate nums when using set() data structure to overwrite nums array, because nums need to be replaced based on index replacement as presented in the Custom Judge criteria. ## use set to filter unique values class Solution: def removeDuplicates(self, nums: list[int]) -\u0026gt; int: nums = list(set(nums)) print(nums) ## for personal evaluation only return len(nums) ## personal evaluation s = Solution() print(f\u0026#34;s.removeDuplicates([1,1,2]): k={s.removeDuplicates([1,1,2])}\u0026#34;) print(f\u0026#34;s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k={s.removeDuplicates([0,0,1,1,1,2,2,3,3,4])}\u0026#34;) ## output [1, 2] s.removeDuplicates([1,1,2]): k=2 [0, 1, 2, 3, 4] s.removeDuplicates([0,0,1,1,1,2,2,3,3,4]): k=5 Back to Site Leetcode Menu "},{"id":1,"href":"/Leetcode/Q27/","title":"Q27","parent":"Leetcode","content":" Remove Element Type: Data Structure Difficulty: EASY Status: COMPLETE Attempts: 4 Solution: NO Link: https://leetcode.com/problems/remove-element/ Tags: Python Array Two Pointers Problem Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1:\nInput: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints:\n\\( 0 \u0026lt;= nums.length \u0026lt;= 100 \\) \\( 0 \u0026lt;= nums[i] \u0026lt;= 50 \\) \\( 0 \u0026lt;= val \u0026lt;= 100 \\) Solution This question is a fairly easy question and there are couple of methods that can be used to solve this problem with Python.\nThere are 2 inputs, a list nums and an integer val, and there should be 1 output, an int type. However, Leetcode also evaluates the last output of the first k elements from the final nums list after removing val values from the list. This mean that Leetcode final evaluations for this problem is based on the output integer and final nums list values. We will explain more in details.\nUsing the first example as demo, nums list consists of 4 elements.\n[3, 2, 2, 3] In this 4 elements list, val is 3 indicates that element 3 from the list will need to be removed and in Python, removing the element will automatically have the list contracted, which are not the case for languages such as Java and C++. However, the question does not care about the final length of the list but just the first k elements of the list.\n## first element is 3; therefore, remove [2, 2, 3] ## second and third element are retained \u0026amp; last element is 3; therefore, removed [2, 2] The final output is length 2 and [2, 2] list.\nSpace complexity is required to be O(1) which means that list should not be referenced to a variable. Attempt 1 This attempt is straightforward by just looping through each element to check if current element matches val. This method does not reduce the length of list but will moved the element values to the front k.\nprint(f\u0026quot;nums: {nums}\u0026quot;) is for reference only by showing the list structure because Leetcode will evaluate nums on-fly; therefore, final structure of nums is the key to pass Leetcode submission. Remove this line when copy and run in Leetcode environment. ## Brute-Force Approach class Solution: def removeElement(self, nums: list[int], val: int) -\u0026gt; int: k = 0 ## count nums of elements ## O(n) time complexity for idx in range(len(nums)): ## increment k if not match vals if nums[idx] != val: nums[k] = nums[idx] k += 1 print(f\u0026#34;nums: {nums}\u0026#34;) return k ## personal evaluation s = Solution() print(f\u0026#34;s.removeElement([3, 2, 2, 3], 3): k={s.removeElement([3, 2, 2, 3], 3)}\u0026#34;) print(f\u0026#34;s.removeElement([0,1,2,2,3,0,4,2], 2): k={s.removeElement([0,1,2,2,3,0,4,2], 2)}\u0026#34;) ## output nums: [2, 2, 2, 3] s.removeElement([3, 2, 2, 3], 3): k=2 nums: [0, 1, 3, 0, 4, 0, 4, 2] s.removeElement([0,1,2,2,3,0,4,2], 2): k=5 Runtime: 55 ms Memory: 14 mb Attempt 2 Using Python built-in remove() method to remove the element from list nums, note that remove() will remove the elements from the list, thus, reducing the length of the list. Therefore, indexing will need to take consideration of element being moved from 1 position to another position.\nFor example,\n## starting with this small example nums -\u0026gt; [3, 2, 2, 3] val -\u0026gt; 3 ## first loop idx -\u0026gt; 0 len(nums) -\u0026gt; 4 nums[0] -\u0026gt; 3 if nums[idx] == val: ## matches [3, 2, 2, 3].remove(3) -\u0026gt; [2, 2, 3] ## second loop nums -\u0026gt; [2, 2, 3] idx -\u0026gt; 0 len(nums) -\u0026gt; 3 nums[0] -\u0026gt; 2 if nums[idx] == val: ## NO matches idx += 1 -\u0026gt; 1 ## third loop nums -\u0026gt; [2, 2, 3] idx -\u0026gt; 1 len(nums) -\u0026gt; 3 nums[1] -\u0026gt; 2 if nums[idx] == val: ## NO matches idx += 1 -\u0026gt; 2 ## fourth loop nums -\u0026gt; [2, 2, 3] idx -\u0026gt; 2 len(nums) -\u0026gt; 3 nums[2] -\u0026gt; 3 if nums[idx] == val: ## matches [2, 2, 3].remove(3) -\u0026gt; [2, 2] ## final output len(nums) -\u0026gt; 2 nums -\u0026gt; [2, 2] ## Using remove method class Solution: def removeElement(self, nums: list[int], val: int) -\u0026gt; int: idx = 0 ## initialize list index ## complexity of O(n) using loop rather than iteration ## as len(nums) will change after each while-loop while idx \u0026lt; len(nums): ## remove element that matches val if nums[idx] == val: nums.remove(val) ## only increment index when matching failed else: idx += 1 print(f\u0026#34;nums: {nums}\u0026#34;) return len(nums) ## personal evaluation s = Solution() print(f\u0026#34;s.removeElement([3, 2, 2, 3], 3): k={s.removeElement([3, 2, 2, 3], 3)}\u0026#34;) print(f\u0026#34;s.removeElement([0,1,2,2,3,0,4,2], 2): k={s.removeElement([0,1,2,2,3,0,4,2], 2)}\u0026#34;) ## output nums: [2, 2] s.removeElement([3, 2, 2, 3], 3): k=2 nums: [0, 1, 3, 0, 4] s.removeElement([0,1,2,2,3,0,4,2], 2): k=5 Runtime: 60 ms Memory: 13.8 mb Attempt 3 pop() is a built-in list method dir(list) and uses similar concept as remove() method does when removing items; the differences is that pop() relies on index while remove() relies on element for removing list elements. To make this code shorter and easy, the loop starts from the end of list index position and move through the first index of the list. Think of this as moving pointer from the end to beginning.\n## using pop method class Solution: def removeElement(self, nums: list[int], val: int) -\u0026gt; int: ## looping from the end of index ## ease index count for idx in range(len(nums), 0, -1): ## range(include, exclude, steps); true index matches idx - 1 idx = idx - 1 ## pop away when element matches val if nums[idx] == val: nums.pop(idx) print(f\u0026#34;nums: {nums}\u0026#34;) return len(nums) ## personal evaluation s = Solution() print(f\u0026#34;s.removeElement([3, 2, 2, 3], 3): k={s.removeElement([3, 2, 2, 3], 3)}\u0026#34;) print(f\u0026#34;s.removeElement([0,1,2,2,3,0,4,2], 2): k={s.removeElement([0,1,2,2,3,0,4,2], 2)}\u0026#34;) ## output nums: [2, 2] s.removeElement([3, 2, 2, 3], 3): k=2 nums: [0, 1, 3, 0, 4] s.removeElement([0,1,2,2,3,0,4,2], 2): k=5 Runtime: 41 ms Memory: 13.9 mb Attempt 4 The last attempt uses list comprehension. As stated in Python performance tips, list comprehension shall perform much faster than loop when the list is small. Also, list comprehension should take lower memory than a loop to process due to elements being stored in memory as hash object. For those who are familiar with Spark framework, this can be think of as Spark lazy loading operation.\nLeetcode is not able to evaluate nums when using list comprehension. The debugger in Leetcode seems to suggest that Leetcode has been evaluated nums as an iterator object through out the loop; therefore, takes only the input nums as submission rather than finalize nums for submission. Thus, this will not work in Leetcode but the solutions is correct. ## list comprehension approach class Solution: def removeElement(self, nums: list[int], val: int) -\u0026gt; int: ## use list comprehension \u0026amp; len method for O(1) space complexity nums = [x for x in nums if x != val] print(f\u0026#34;nums: {nums}\u0026#34;) return len(nums) ## personal evaluation s = Solution() print(f\u0026#34;s.removeElement([3, 2, 2, 3], 3): k={s.removeElement([3, 2, 2, 3], 3)}\u0026#34;) print(f\u0026#34;s.removeElement([0,1,2,2,3,0,4,2], 2): k={s.removeElement([0,1,2,2,3,0,4,2], 2)}\u0026#34;) ## output nums: [2, 2] s.removeElement([3, 2, 2, 3], 3): k=2 nums: [0, 1, 3, 0, 4] s.removeElement([0,1,2,2,3,0,4,2], 2): k=5 Back to Site Leetcode Menu "},{"id":2,"href":"/Leetcode/Q217/","title":"Q217","parent":"Leetcode","content":" Contains Duplicate Type: Data Structure Difficulty: EASY Status: IN PROGRESS Attempts: 1 Solution: NO Link: https://leetcode.com/problems/contains-duplicate/ Tags: Python Array Hash Table Sorting Problem Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1] Output: true Example 2:\nInput: nums = [1,2,3,4] Output: false Example 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints:\n\\( 1 \u0026lt;= nums.length \u0026lt;= 10^5 \\) \\( -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 \\) Solution Attempt 1 ## body solution class Solution: def containsDuplicate(self, nums: list[int]) -\u0026gt; bool: ## collect elements as sets, better memory management than list temp = set() ## check if any values is no the set for i in nums: ## return true if there is one if i in temp: return True ## add the element into the set temp.add(i) ## if none has replicate return false return False ## initialize variables s = Solution() print(s.containsDuplicate([1, 2, 3, 1])) print(s.containsDuplicate([1, 2, 3, 4])) print(s.containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2])) # assert s.containsDuplicate([1, 2, 3, 1]) == True, \u0026#34;Should be True\u0026#34; # assert(s.containsDuplicate([1, 2, 3, 4]) == False, \u0026#34;Should be False\u0026#34;) # assert(s.containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True, \u0026#34;Should be True\u0026#34;) Back to Site Leetcode Menu "},{"id":3,"href":"/","title":"👋 Hello World !!","parent":"","content":" Congratulation 🚀 on Landing 🛬 to Our Site !! 🛸 This site currently contains problem solving attempts on Leetcode questions for the purpose of collaborating and practicing, however, both authors envision a better site that shall contain resources covering data science learning techniques and posts covering beginner friendly solutions and knowledge for the peers. This site is currently in experimental phase and more are expected to be added. These expected items are referred as the current backlogs, presented below, and the authors hope to be able to complete these asap to make this site a fully functional site for educational and development purposes. About us Leetcode BACKLOGS (For Possible Further Site Improvement) DS \u0026amp; Algo Contents Continue to add more data structures and algorithms contents from Leetcode for peers to reference and learn. Comment Box Provide commenting tools for peers to provide feedbacks and interaction with the posts to help improve the current solutions and for futher site and content improvements. Language Support Provide Mandarin as second language support for peers to be able to study and work in bilingual mode. Python Knowledge Stop Answer common Python questions that can be found from Google, Stack Overflow, etc. to provide a one-time stop for peers without having to read through different blogs and articles to obtain the solution they need. DS Knowledge Hub Provide articles and notes that cover fundamental tools use in the Data Science realm which might cover descriptive, diagnosis, predictive, and prescriptive analysis. Programming Language Intended to provide SQL \u0026amp; C++ knowledge support for peers that relies on these tools for job search, interview, projects, etc. This site is proudly built with HUGO using Geekdocs theme hosted on GitHub. "},{"id":4,"href":"/Leetcode/","title":"Leetcode","parent":"👋 Hello World !!","content":"This section is dedicated in looking into both authors\u0026rsquo; thinking and approach uses to tackle Leetcode data structure and algorithmic problems and is intended for note-taking and self-development. Thus, please be advise to think independently when using the authors problem solving ideas. The authors highly encourage and welcome new ideas and feedbacks for any improvements.\nRemember: There is no such thing as stupid questions! 🤗\nDo note that both authors are self-taught programmers whom are neither experienced software engineers nor have completed any CS or CE related degrees. Our advise for any beginner learner is to think before copy. Leetcode Question Q26 Remove Duplicates from Sorted Array Q27 Remove Elements Q217 Contains Duplicate "},{"id":5,"href":"/About/","title":"About us","parent":"👋 Hello World !!","content":" HOME PAGE JKChai 🙌 JKChai is a BI Developer graduated with Quant Finance, Data Science \u0026amp; Business Analytics degrees and had worked as a Software Integration Analyst. Although the author current focus is in the realm of data; however, his passion in software has led him to continue discovering and learning new tools and techniques for building software that can solve his and others\u0026rsquo; problems. JKChai hopes to end up in the backend world as he believes that building and maintaining the backend systems infrastructure is the cornerstone for better future good. Lun 🤝 Lun has a Psychology degree and had previously worked as a teacher, sales, and admin. He is a self-taught programmer and has recently involved himself more working with data science project on Kaggle to enhance his problem solving skills. In terms of career goal, he hopes to become a Software Development Engineer by using his learned computer science skills and techniques to help solved industry problems. Thus, he continues to pursue his dream through learning and practicing from the web and peers. "},{"id":6,"href":"/tags/","title":"Tags","parent":"👋 Hello World !!","content":""}]